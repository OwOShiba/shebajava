"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Command = exports.CommandType = void 0;
const zod_1 = require("zod");
const Argument_1 = require("./Argument");
const GClient_1 = require("../GClient");
const CommandManager_1 = require("../managers/CommandManager");
const common_1 = require("../util/common");
const Logger_1 = require("../util/logger/Logger");
const regexes_1 = require("../util/regexes");
const discord_js_1 = require("discord.js");
const Util_1 = require("../util/Util");
var CommandType;
(function (CommandType) {
    /**
     * ![](https://garlic-team.js.org/guide/message.png)
     */
    CommandType[CommandType["MESSAGE"] = 0] = "MESSAGE";
    /**
     * ![](https://garlic-team.js.org/guide/slash.png)
     */
    CommandType[CommandType["SLASH"] = 1] = "SLASH";
    /**
     * ![](https://garlic-team.js.org/guide/context_user.png)
     */
    CommandType[CommandType["CONTEXT_USER"] = 2] = "CONTEXT_USER";
    /**
     * ![](https://garlic-team.js.org/guide/context_message.png)
     */
    CommandType[CommandType["CONTEXT_MESSAGE"] = 3] = "CONTEXT_MESSAGE";
})(CommandType = exports.CommandType || (exports.CommandType = {}));
const validationSchema = zod_1.z
    .object({
    name: zod_1.z.string().max(32).regex(regexes_1.commandAndOptionNameRegexp),
    nameLocalizations: zod_1.z
        .record(zod_1.z
        .union([zod_1.z.string(), zod_1.z.nativeEnum(common_1.Locale)])
        .transform(arg => typeof arg === 'string' && Object.keys(common_1.Locale).includes(arg)
        ? common_1.Locale[arg]
        : arg), zod_1.z.string().max(32).regex(regexes_1.commandAndOptionNameRegexp))
        .optional(),
    description: zod_1.z.string().max(100),
    descriptionLocalizations: zod_1.z
        .record(zod_1.z
        .union([zod_1.z.string(), zod_1.z.nativeEnum(common_1.Locale)])
        .transform(arg => typeof arg === 'string' && Object.keys(common_1.Locale).includes(arg)
        ? common_1.Locale[arg]
        : arg), zod_1.z.string().max(100))
        .optional(),
    type: zod_1.z
        .union([zod_1.z.string(), zod_1.z.nativeEnum(CommandType)])
        .transform(arg => typeof arg === 'string' && Object.keys(CommandType).includes(arg)
        ? CommandType[arg]
        : arg)
        .array()
        .nonempty(),
    defaultMemberPermissions: zod_1.z.any().optional(),
    dmPermission: zod_1.z.boolean().optional(),
    arguments: zod_1.z.any().array().optional(),
    inhibitors: zod_1.z.any().array().optional().default([]),
    guildId: zod_1.z.string().optional(),
    cooldown: zod_1.z.string().optional(),
    autoDefer: zod_1.z
        .union([zod_1.z.string(), zod_1.z.nativeEnum(GClient_1.AutoDeferType)])
        .transform(arg => typeof arg === 'string' && Object.keys(GClient_1.AutoDeferType).includes(arg)
        ? GClient_1.AutoDeferType[arg]
        : arg)
        .optional(),
    fileName: zod_1.z.string().optional(),
    run: zod_1.z.function(),
    onError: zod_1.z.function().optional(),
})
    .passthrough();
class Command {
    constructor(options) {
        this.reloading = false;
        if (this.run)
            options.run = this.run;
        if (this.onError)
            options.onError = this.onError;
        validationSchema
            .parseAsync({ ...options, ...this })
            .then(options => {
            this.name = options.name ?? Command.defaults?.name;
            this.nameLocalizations =
                options.nameLocalizations ?? Command.defaults?.nameLocalizations;
            this.description = options.description ?? Command.defaults?.description;
            this.descriptionLocalizations =
                options.descriptionLocalizations ??
                    Command.defaults?.descriptionLocalizations;
            this.type = options.type ?? Command.defaults?.type;
            this.defaultMemberPermissions =
                options.defaultMemberPermissions ??
                    Command.defaults?.defaultMemberPermissions;
            this.dmPermission =
                options.dmPermission ?? Command.defaults?.dmPermission;
            this.arguments = options.arguments?.map(argument => {
                if (argument instanceof Argument_1.Argument)
                    return argument;
                else
                    return new Argument_1.Argument(argument);
            });
            this.inhibitors =
                options.inhibitors.length > 0
                    ? options.inhibitors
                    : Command.defaults?.inhibitors;
            this.guildId = options.guildId ?? Command.defaults?.guildId;
            this.cooldown = options.cooldown ?? Command.defaults?.cooldown;
            this.fileName = options.fileName ?? Command.defaults?.fileName;
            this.run = options.run ?? Command.defaults?.run;
            this.onError = options.onError ?? Command.defaults?.onError;
            this.autoDefer = options.autoDefer ?? Command.defaults?.autoDefer;
            this.options = { ...Command.defaults, ...options };
            CommandManager_1.Commands.register(this);
        })
            .catch(error => {
            Logger_1.Logger.warn(typeof error.code !== 'undefined' ? error.code : '', error.message);
            if (error.stack)
                Logger_1.Logger.trace(error.stack);
        });
    }
    initialize(client) {
        this.client = client;
        if (!this.guildId && client.options?.devGuildId)
            this.guildId = client.options.devGuildId;
    }
    unregister() {
        return CommandManager_1.Commands.unregister(this.name);
    }
    async inhibit(ctx) {
        if (!this.inhibitors)
            return true;
        for await (const inhibitor of this.inhibitors) {
            if ((await Util_1.Util.runInhibitor(ctx, inhibitor)) !== true)
                return false;
        }
        return true;
    }
    async reload() {
        if (!this.fileName)
            return;
        this.reloading = true;
        delete require.cache[require.resolve(this.fileName)];
        await Promise.resolve().then(() => __importStar(require(this.fileName)));
        return CommandManager_1.Commands.get(this.name);
    }
    toJSON() {
        return this.type
            .filter(type => type !== CommandType.MESSAGE)
            .map(type => {
            if (type === CommandType.SLASH) {
                return {
                    name: this.name,
                    name_localizations: this.nameLocalizations,
                    description: this.description,
                    description_localizations: this.descriptionLocalizations,
                    dm_permission: this.dmPermission,
                    default_member_permissions: this.defaultMemberPermissions
                        ? new discord_js_1.Permissions(this.defaultMemberPermissions).bitfield.toString()
                        : null,
                    options: this.arguments?.map(argument => argument.toJSON()),
                    type: type,
                };
            }
            else {
                return {
                    name: this.name,
                    type: type,
                };
            }
        });
    }
    static setDefaults(defaults) {
        validationSchema
            .partial()
            .parseAsync(defaults)
            .then(defaults => {
            Command.defaults = defaults;
        })
            .catch(error => {
            Logger_1.Logger.warn(typeof error.code !== 'undefined' ? error.code : '', error.message);
            if (error.stack)
                Logger_1.Logger.trace(error.stack);
        });
    }
}
exports.Command = Command;
